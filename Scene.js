// Generated by CoffeeScript 1.12.4
import {ScreenManager} from "./ScreenManager";
import {SceneManager} from "./SceneManager";
import {AppContext} from "./utils/AppContext";
import {delegate} from "./utils/tools";

const Scene = (function () {
    Scene.autoScrollSpeed = 1000;

    const touchSpeedFactor = 4;


    /**
     * créé la scène à partir de son dom et de son alias
     * @param {object} Dom jquery de la scène
     * @param {string} alias de la scène
     * @return {Scene} scene créé
     */

    Scene.create = function (dom, alias) {
        return new this(dom, alias);
    };


    /**
     * constructeur de la scène
     * @param {object} dom jquery de la scène
     * @param {string} alias de la scène
     */
    function Scene(dom, alias) {
        this.mainWrapper = 'body';
        this.alias = alias;
        this.dom = dom;
        this.screens = ScreenManager.createScreenOfScene(this);
        // this.isFullscreen = this.dom.hasClass("fullscreen");
        this.scrollLabels = [];
        this.nvVertical = $('.nv-vertical');
        this.labelCallback = delegate(ScreenManager, ScreenManager.labelCallback);
        if (AppContext.isLowIE && this.alias === 'scene_intro') {
            this.dom.css('-ms-transform', 'translate(0, 0)');
        }
    }


    /*
     * rafraichichement du viewport de la scène, appellé après le build de la scène et à chaque changement de taill de fenêtre
     */

    Scene.prototype.refreshViewport = function (initLayers = false) {
        // if (this.isFullscreen) {
        //     this.dom.css({
        //         width: window.innerWidth + "px",
        //         height: window.innerHeight + "px"
        //     });
        // }
        this.refreshViewportInformation();
        this.refreshScreenViewport(initLayers);
    };

    /*
     * Met à jour les informations sur le viewport de la scène
     */

    Scene.prototype.refreshViewportInformation = function () {
        const ww = this.mainWrapper.width();
        const wh = this.mainWrapper.height();
        let w, h;
        if (window.innerWidth / window.innerHeight < 16 / 9) {
            w = window.innerWidth > 1280 ? 1280 : ww;
            h = w / 16 * 9;
        } else {
            h = window.innerHeight > 720 ? 720 : wh;
            w = h * 16 / 9;
        }

        this.viewport = {
            width: this.dom.outerWidth(),
            height: this.dom.outerHeight(),
            // windowWidth: $(window).width(),
            // windowHeight: $(window).height()
            windowWidth: w,
            windowHeight: h,
            marginTop: (window.innerHeight - h) / 2,
            marginLeft: (window.innerWidth - w) / 2
        };
    };

    /**
     * raffraichi le viewport des écrans
     */

    Scene.prototype.refreshScreenViewport = function (initLayers) {
        var i, len, ref, results, screen;
        ref = this.screens;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
            screen = ref[i];
            if ((screen.refreshViewport !== null)) {
                results.push(screen.refreshViewport(initLayers));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };


    /**
     * fonction de build du composant : apellé depuis la function buildNewScene de SceneManager (après que les assets soit chargés)
     */

    Scene.prototype.build = function () {
        if ((this.preBuild !== null)) {
            this.preBuild();
        }
        this.buildScreens();
        if ((this.postBuild !== null)) {
            this.postBuild();
        }

        // refresh and init layer positions
        this.refreshViewport(true);

        // refresh window size without layer on resize
        let buffer;
        $(window).on('resize', this.refreshViewport.bind(this));
        // $(window).on('resize', () => {
        //     clearTimeout(buffer);
        //     buffer = setTimeout(() => this.refreshViewport(), 250);
        // });
    };


    /*
     build stuff before setting the triggers
     @note children classes must call the super() method
     */

    Scene.prototype.preBuild = function () {
        // $('.loader-avatar').attr('src', 'assets/images/avatars/avatar-' + this.user.getAvatar() + '.png');
    };


    /*
     postBuild
     */

    Scene.prototype.postBuild = function () {
        $('.next-label').on('click', function (e) {
            SceneManager.unlockScroll(true);
            return false;
        });
    };


    /*
     * Build des écrans (appellé depuis la function Build)
     */

    Scene.prototype.buildScreens = function () {
        var i, len, ref, results, screen;
        ref = this.screens;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
            screen = ref[i];
            results.push(screen.build());
        }
        return results;
    };


    /*
     * Fonction abstraite d'entrée et de sorti de scène
     */

    Scene.prototype.onLeaveStage = function (from) {
    };

    Scene.prototype.onEnterStage = function (from) {

        /**
         * Récupère un écran à partir de son nom
         * @param {string} nom de l'écran
         */
    };

    Scene.prototype.getScreen = function (name) {
        var i, len, ref, screen;
        ref = this.screens;
        for (i = 0, len = ref.length; i < len; i++) {
            screen = ref[i];
            if (screen.name === name) {
                return screen;
            }
        }
    };


    /**
     * Récupère un écran à partir de son nom
     * @param {string} alias de l'écran
     */

    Scene.prototype.getScreenOfAlias = function (alias) {
        var i, len, ref, res, screen;
        res = [];
        ref = this.screens;
        for (i = 0, len = ref.length; i < len; i++) {
            screen = ref[i];
            if (screen.name === alias) {
                res.push(screen);
            }
        }
        return res;
    };


    /**
     * Helper de création de scroll timeline
     * @param {object} timeline associated with the animation
     * @param {int} nombre d'écran utilisé pour définir la durée de la scène scrollmagic
     * @param {float} trigger hook de la scène : 0 déclenché en haut de l'écran, 1:déclenché en bas de l'écran
     * @param {object} pin de l'animation : par défaut le dom de la scène
     */

    Scene.prototype.addTimeline = function (timeline, label) {
        if (label == null) {
            label = null;
        }
        if (label) {
            SceneManager.mainTimeline().addLabel(label);
        }
        SceneManager.mainTimeline().add(timeline);
    };


    /**
     * Helper pour le debug
     * @return {string} description de l'écran
     */

    Scene.prototype.toString = function () {
        return "[Scene " + this.alias + "]";
    };

    return Scene;

})();

export {Scene};
